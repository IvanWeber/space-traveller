<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Planet Capsule ‚Äì Realistic Atmosphere + Proper Sun Light</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
  #hud {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: monospace;
    background: rgba(0, 0, 0, 0.4);
    padding: 5px 10px;
    border-radius: 8px;
  }
</style>
</head>
<body>
<div id="hud">
  WASD ‚Äì –¥–≤–∏–∂–µ–Ω–∏–µ<br>
  –ú—ã—à—å ‚Äì –ø–æ–≤–æ—Ä–æ—Ç –Ω–æ—Å–∞ (–≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ) + –∫–∞–º–µ—Ä–∞ –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑<br>
  Space ‚Äì –Ω–∏–∂–Ω–µ–µ —Å–æ–ø–ª–æ (–ø—Ä—ã–∂–æ–∫)<br>
  üåå –ê—Ç–º–æ—Å—Ñ–µ—Ä–∞ –≥–æ–ª—É–±–µ–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ –æ—Å–≤–µ—â—ë–Ω–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–µ<br>
  üåû –°–æ–ª–Ω—Ü–µ —Ç–µ–ø–µ—Ä—å –¥–∞–ª—å—à–µ –∏ —Å–≤–µ—Ç–∏—Ç —Ç–æ—á–Ω–æ –∏–∑ —Å–≤–æ–µ–≥–æ —Ü–µ–Ω—Ç—Ä–∞
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

<script>
//// === –°–¶–ï–ù–ê ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 5000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

//// === –°–í–ï–¢ ===
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(1000, 800, 1000);  // –°–æ–ª–Ω—Ü–µ —Ç–µ–ø–µ—Ä—å –¥–∞–ª–µ–∫–æ
scene.add(sun);

// —Ü–µ–ª–∏–º—Å—è –≤ —Ü–µ–Ω—Ç—Ä —Å—Ü–µ–Ω—ã (–∏–ª–∏ –º–æ–∂–Ω–æ –≤ –∫–æ—Ä–∞–±–ª—å)
sun.target.position.set(0, 0, 0);
scene.add(sun.target);

// –º—è–≥–∫–∏–µ —Ç–µ–Ω–∏/–æ—Å–≤–µ—â–µ–Ω–∏–µ
scene.add(new THREE.AmbientLight(0x222222));

//// === üåû –°–û–õ–ù–¶–ï-–®–ê–† ===
const sunSize = 120; // —É–≤–µ–ª–∏—á–∏–º —Å–æ–ª–Ω—Ü–µ –≤–∏–∑—É–∞–ª—å–Ω–æ
const sunGeo = new THREE.SphereGeometry(sunSize, 64, 64);

// —à–µ–π–¥–µ—Ä –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞ –±–µ–ª–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∞ –≤ –∂–µ–ª—Ç—ã–µ –∫—Ä–∞—è
const sunMat = new THREE.ShaderMaterial({
  uniforms: {
    colorCenter: { value: new THREE.Color(0xffffff) },
    colorEdge: { value: new THREE.Color(0xffcc33) }
  },
  vertexShader: `
    varying vec3 vNormal;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vNormal;
    uniform vec3 colorCenter;
    uniform vec3 colorEdge;
    void main() {
      float intensity = pow(1.0 - length(vNormal.xy), 1.5);
      vec3 color = mix(colorEdge, colorCenter, intensity);
      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.FrontSide
});

const sunMesh = new THREE.Mesh(sunGeo, sunMat);
sunMesh.position.copy(sun.position);  // —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º —Å–≤–µ—Ç–∞
scene.add(sunMesh);

//// === –§–ò–ó–ò–ö–ê ===
const world = new CANNON.World();
world.gravity.set(0, 0, 0);

//// === –®–ê–•–ú–ê–¢–ù–ê–Ø –¢–ï–ö–°–¢–£–†–ê ===
function createCheckerTexture(size = 512, squares = 16) {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  const squareSize = size / squares;
  for (let y = 0; y < squares; y++) {
    for (let x = 0; x < squares; x++) {
      ctx.fillStyle = (x + y) % 2 === 0 ? '#ffffff' : '#000000';
      ctx.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
    }
  }
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(8, 8);
  return texture;
}

//// === –ü–õ–ê–ù–ï–¢–´ ===
function createPlanet(radius, x, y, z, color) {
  const geo = new THREE.SphereGeometry(radius, 64, 64);
  const mat = new THREE.MeshStandardMaterial({ map: createCheckerTexture(), roughness: 1, color });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, z);
  scene.add(mesh);

  const body = new CANNON.Body({ mass: 1e6 });
  body.addShape(new CANNON.Sphere(radius));
  body.position.set(x, y, z);
  world.addBody(body);

  return { mesh, body, radius };
}

const planet1 = createPlanet(200, 0, 0, 0, 0xffffff);
const planet2 = createPlanet(150, 600, 100, 0, 0xffdddd);

//// === –û–†–ë–ò–¢–ê–õ–¨–ù–´–ô –ü–ò–ù–û–ö ===
const ORBIT_IMPULSE = 2.5e7;

const between = new CANNON.Vec3().copy(planet2.body.position).vsub(planet1.body.position);
between.normalize();
const orbitDir = new CANNON.Vec3(0, 1, 0).cross(between);
orbitDir.normalize();

planet1.body.applyImpulse(
  new CANNON.Vec3(orbitDir.x * ORBIT_IMPULSE, orbitDir.y * ORBIT_IMPULSE, orbitDir.z * ORBIT_IMPULSE),
  planet1.body.position
);
planet2.body.applyImpulse(
  new CANNON.Vec3(-orbitDir.x * ORBIT_IMPULSE, -orbitDir.y * ORBIT_IMPULSE, -orbitDir.z * ORBIT_IMPULSE),
  planet2.body.position
);

//// === –§–ò–ó–ò–ß–ï–°–ö–ò–ô –®–ê–† (–ö–ê–ü–°–£–õ–ê) ===
const BALL_RADIUS = 3;
const ballBody = new CANNON.Body({ mass: 5 });
ballBody.addShape(new CANNON.Sphere(BALL_RADIUS));
ballBody.position.set(0, 200 + BALL_RADIUS, 0);
world.addBody(ballBody);

//// === –ö–ê–ü–°–£–õ–ê ===
const CAPSULE_HEIGHT = 10;
const CAPSULE_RADIUS = 4;
const capsuleGeo = new THREE.CapsuleGeometry(CAPSULE_RADIUS, CAPSULE_HEIGHT, 8, 16);
const capsuleMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const capsuleMesh = new THREE.Mesh(capsuleGeo, capsuleMat);
scene.add(capsuleMesh);

//// === –°–û–ü–õ–ê ===
const thrusterMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
const flameMat = new THREE.MeshBasicMaterial({ color: 0xff5500 });

function createThruster(offset) {
  const geo = new THREE.PlaneGeometry(2, 2);
  const mesh = new THREE.Mesh(geo, thrusterMat);
  mesh.position.copy(offset);
  capsuleMesh.add(mesh);

  const flame = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), flameMat);
  flame.visible = false;
  mesh.add(flame);
  flame.position.set(0, 0, -0.6);

  return { mesh, flame };
}

const thrusters = {
  back: createThruster(new THREE.Vector3(0, 0, CAPSULE_RADIUS+0.6)),
  front: createThruster(new THREE.Vector3(0, 0, -CAPSULE_RADIUS-0.6)),
  right: createThruster(new THREE.Vector3(CAPSULE_RADIUS+0.6, 0, 0)),
  left: createThruster(new THREE.Vector3(-CAPSULE_RADIUS-0.6, 0, 0)),
  bottom: createThruster(new THREE.Vector3(0, -CAPSULE_HEIGHT/2-0.5, 0))
};

//// === –ò–ù–ü–£–¢ ===
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
document.body.addEventListener('click', () => document.body.requestPointerLock());

//// === YAW/PITCH ===
let pitch = 0;
const yawQuatOffset = new THREE.Quaternion();
const currentYawQuat = new THREE.Quaternion();

document.addEventListener('mousemove', (e) => {
  if (document.pointerLockElement === document.body) {
    const deltaYaw = e.movementX * -0.002;
    const deltaQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), deltaYaw);
    yawQuatOffset.multiplyQuaternions(deltaQuat, yawQuatOffset);

    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch));
  }
});

//// === –ü–ê–†–ê–ú–ï–¢–†–´ ===
const clock = new THREE.Clock();
const GRAVITY_FORCE = 200;
const PLANET_GRAVITY_G = -0.5;
const THRUST_FORCE = 150;
const JUMP_FORCE = 100;
const ATMOSPHERE_THICKNESS = BALL_RADIUS * 30;

const UP_TRANSITION_SMOOTHNESS = 0.02;
const VERTICAL_AXIS_ROTATION_PHYSICS = 0.05;

let currentUpVec = new THREE.Vector3(0, 1, 0);

function getClosestPlanet() {
  const d1 = ballBody.position.distanceTo(planet1.body.position);
  const d2 = ballBody.position.distanceTo(planet2.body.position);
  return d1 < d2 ? planet1 : planet2;
}

//// === –ê–ù–ò–ú–ê–¶–ò–Ø ===
const targetQuat = new THREE.Quaternion();
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // === –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –Ω–∞ –∫–∞–ø—Å—É–ª—É ===
  [planet1, planet2].forEach(planet => {
    const toPlanet = new CANNON.Vec3(
      planet.body.position.x - ballBody.position.x,
      planet.body.position.y - ballBody.position.y,
      planet.body.position.z - ballBody.position.z
    );
    const dist = toPlanet.length();
    toPlanet.normalize();
    toPlanet.scale(GRAVITY_FORCE / (dist * 0.01), toPlanet);
    ballBody.applyForce(toPlanet, ballBody.position);
  });

  // === –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –º–µ–∂–¥—É –ø–ª–∞–Ω–µ—Ç–∞–º–∏ ===
  const toP2 = new CANNON.Vec3(
    planet2.body.position.x - planet1.body.position.x,
    planet2.body.position.y - planet1.body.position.y,
    planet2.body.position.z - planet1.body.position.z
  );
  const distPlanets = toP2.length();
  if (distPlanets > (planet1.radius + planet2.radius)) {
    toP2.normalize();
    const forceMagnitude = PLANET_GRAVITY_G * planet1.body.mass * planet2.body.mass / (distPlanets * distPlanets);
    const force = new CANNON.Vec3(toP2.x * forceMagnitude, toP2.y * forceMagnitude, toP2.z * forceMagnitude);
    planet2.body.applyForce(force, planet2.body.position);
    planet1.body.applyForce(force.scale(-1), planet1.body.position);
  }

  // === –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–ª–∞–Ω–µ—Ç ===
  planet1.mesh.position.copy(planet1.body.position);
  planet2.mesh.position.copy(planet2.body.position);

  // === –ü–æ–∑–∏—Ü–∏—è –∫–∞–ø—Å—É–ª—ã ===
  capsuleMesh.position.copy(ballBody.position);

  // === –û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è –∫–∞–ø—Å—É–ª—ã ===
  const closestPlanet = getClosestPlanet();
  const desiredUp = new THREE.Vector3()
    .subVectors(capsuleMesh.position, closestPlanet.mesh.position)
    .normalize();
  currentUpVec.lerp(desiredUp, UP_TRANSITION_SMOOTHNESS).normalize();

  const up = currentUpVec.clone();
  const worldForward = new THREE.Vector3(0, 0, -1);
  const worldRight   = new THREE.Vector3(1, 0, 0);

  let right = new THREE.Vector3().crossVectors(up, worldForward);
  if (right.lengthSq() < 0.0001) {
    right = new THREE.Vector3().crossVectors(up, worldRight);
  }
  right.normalize();
  const forwardStabilized = new THREE.Vector3().crossVectors(right, up).normalize();

  const m = new THREE.Matrix4();
  m.makeBasis(right, up, forwardStabilized);
  const baseQuat = new THREE.Quaternion().setFromRotationMatrix(m);

  currentYawQuat.slerp(yawQuatOffset, VERTICAL_AXIS_ROTATION_PHYSICS);
  targetQuat.copy(baseQuat).multiply(currentYawQuat);
  capsuleMesh.quaternion.slerp(targetQuat, 0.15);

  // === –ö–∞–º–µ—Ä–∞ ===
  const cameraDistance = 20;
  const cameraHeight = 5;
  let backOffset = new THREE.Vector3(0, cameraHeight, cameraDistance);
  backOffset.applyQuaternion(capsuleMesh.quaternion);

  const rightAxis = new THREE.Vector3(1,0,0).applyQuaternion(capsuleMesh.quaternion);
  const pitchQuat = new THREE.Quaternion().setFromAxisAngle(rightAxis, pitch);
  backOffset.applyQuaternion(pitchQuat);

  camera.position.copy(capsuleMesh.position).add(backOffset);
  camera.up.copy(up);
  camera.lookAt(capsuleMesh.position);

  // === –≠–§–§–ï–ö–¢ –ê–¢–ú–û–°–§–ï–†–´ ===
  const d1 = capsuleMesh.position.distanceTo(planet1.mesh.position) - planet1.radius;
  const d2 = capsuleMesh.position.distanceTo(planet2.mesh.position) - planet2.radius;
  const minDist = Math.min(d1, d2);
  const planet = (d1 < d2) ? planet1 : planet2;

  if (minDist < ATMOSPHERE_THICKNESS) {
    const t = Math.max(minDist / ATMOSPHERE_THICKNESS, 0);

    const sunDir = new THREE.Vector3().copy(sun.position).sub(planet.mesh.position).normalize();
    const toCapsule = new THREE.Vector3().copy(capsuleMesh.position).sub(planet.mesh.position).normalize();
    let lightFactor = sunDir.dot(toCapsule);
    lightFactor = Math.max(0, lightFactor);

    const dayColor = new THREE.Color(0x3399FF); // –Ω–∞—Å—ã—â–µ–Ω–Ω—ã–π –≥–æ–ª—É–±–æ–π
    const nightColor = new THREE.Color(0x000010);
    const skyColor = new THREE.Color().lerpColors(dayColor, nightColor, 1 - lightFactor).lerp(new THREE.Color(0x000000), t);
    scene.background = skyColor;
  } else {
    scene.background = new THREE.Color(0x000000);
  }

  // === –î–≤–∏–∂–µ–Ω–∏–µ –∏ —Å–æ–ø–ª–∞ ===
  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(capsuleMesh.quaternion);
  const rightVec = new THREE.Vector3(1, 0, 0).applyQuaternion(capsuleMesh.quaternion);

  Object.values(thrusters).forEach(t => t.flame.visible = false);

  if (keys['w']) {
    ballBody.applyForce(new CANNON.Vec3(forward.x*THRUST_FORCE, forward.y*THRUST_FORCE, forward.z*THRUST_FORCE), ballBody.position);
    thrusters.back.flame.visible = true;
  }
  if (keys['s']) {
    ballBody.applyForce(new CANNON.Vec3(-forward.x*THRUST_FORCE, -forward.y*THRUST_FORCE, -forward.z*THRUST_FORCE), ballBody.position);
    thrusters.front.flame.visible = true;
  }
  if (keys['a']) {
    ballBody.applyForce(new CANNON.Vec3(-rightVec.x*THRUST_FORCE, -rightVec.y*THRUST_FORCE, -rightVec.z*THRUST_FORCE), ballBody.position);
    thrusters.right.flame.visible = true;
  }
  if (keys['d']) {
    ballBody.applyForce(new CANNON.Vec3(rightVec.x*THRUST_FORCE, rightVec.y*THRUST_FORCE, rightVec.z*THRUST_FORCE), ballBody.position);
    thrusters.left.flame.visible = true;
  }
  if (keys[' ']) {
    ballBody.applyImpulse(new CANNON.Vec3(up.x*JUMP_FORCE, up.y*JUMP_FORCE, up.z*JUMP_FORCE), ballBody.position);
    thrusters.bottom.flame.visible = true;
  }

  world.step(1/60, dt);
  renderer.render(scene, camera);
}

animate();

//// === RESIZE ===
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
